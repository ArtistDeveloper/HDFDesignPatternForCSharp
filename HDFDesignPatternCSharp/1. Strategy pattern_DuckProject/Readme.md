## 1.전략 패턴(strategy pattern)
![image](https://user-images.githubusercontent.com/40491724/171191181-68213905-6427-48c3-8a84-e50a752dff81.png)

위의 이미지 처럼 코드 구조를 짤 수 있으려면, 인터페이스 형식(굳이 interface가 아닌 상위 형식을 말함)에 맞추어 개발하는 것이 중요합니다.

캡슐화
- 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 ‘캡슐화’ 합니다.
- 이러면 나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있습니다.
- 이 방법은 모든 패턴의 기반을 이루는 원칙입니다.


디자인 원칙
- 상속보다는 구성을 활용한다.
- 구현보다는 인터페이스에 맞춰서 프로그래밍한다.

## 상속과 구성

책에서 구성을 예시로 든 설명은 다음과 같습니다.
- "A에는 B가 있다" 관게를 생각해 봅시다. (Duck 클래스에 FlyBehavior와 QuackBehavior가 있다는 것을 말하고 싶은 것 같습니다.)
- 각 오리에는 FlyBehavior와 QuackBehavior가 있으며, 각각 나는 행동과 꽥꽥거리는 행동을 위임 받습니다.
- 이런 식으로 두 클래스를 합치는 것을 '구성(Composition)을 이용한다'라고 부릅니다.
- 오리 클래스에서는 행동을 상속받는 대신, 올바른 행동 객체로 구성되어 행동을 부여 받습니다.

그리고 추가적으로 상속과 구성에 대해 설명을 해보겠습니다.

### 상속의 단점

캡슐화를 위반한다.
- 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있기 때문입니다.
- 상위 클래스의 내부 구현이 달라지면 하위 클래스를 고쳐야할 수 있습니다.

설계가 유연하지 못하다.
- 컴파일 시점에 객체의 Type이 정해지기 때문입니다.

다중상속
- C#, Java는 다중상속이 불가능합니다.
- 따라서 다른 클래스를 상속받고 있다면 추가적으로 상속을 받을 수 없습니다.

이러한 것을 





### 전략 패턴
알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해 줍니다. 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 분리할 수 있습니다.

