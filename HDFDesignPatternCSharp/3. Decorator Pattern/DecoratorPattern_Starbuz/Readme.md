# 초대형 커피 전문점, 스타버즈

사업을 시작할 무렵에 만들어진 주문 시스템 클래스는 다음과 같이 구성되었습니다.

![image](https://user-images.githubusercontent.com/40491724/173288129-331f72c2-338b-4e12-8504-f8e8a00b3d88.png)


그러나, 사업이 성공하고 규모가 커질수록 다양한 음료가 나오게 되었고 그에 맞춰 고객은 커피를 주문할 때 우유나 두유, 모카(초콜릿)을 추가하고 그 위에 휘핑크림을 얹기도 합니다.
그래서 각각을 추가할 때마다 커피 가격이 올라가야 하기에 주문 시스템을 구현할 때 이런 점을 모두 고려해야 합니다.

그래서 처음에는 시스템이 이런식으로 확장되었습니다.
![image](https://user-images.githubusercontent.com/40491724/173288149-6470c7df-2830-446c-8fb5-8171260dd3aa.png)


> cost() 메소드는 첨가물도 포함해서 커피의 최종 가격을 계산해줍니다.

기존시스템의 구조로 확장을 하다보니 클래스가 너무 많아지게 되었습니다.

위와 같은 구조의 문제점은 다음과 같습니다.
- 바뀌는 부분이 캡술화 되어있지 않습니다.
- 구성을 사용하지 않고 상속에 얽매여 있습니다.

## 1. 이 문제를 해결해볼 첫 번째 접근법
인스턴스 변수와 슈퍼클래스 상속을 써서 첨가물을 관리해봅시다.





## 디자인 원칙

### OCP(Open-Closed principle)
- 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다.

우리의 목표는 기존 코드를 건드리지 않고 확장으로 새로운 행동을 추가하는 것입니다. 이 목표를 달성했을 때 얻을 수 있는 것은 새로운 기능을 추가할 때 급변하는 주변 환경에 잘 적응하는 유연하고 튼튼한 디자인을 만들 수 있습니다.

**모든 부분에서 OCP를 준수하려면 어떻게 해야 하나요?**
- 모든 부분에서 OCP를 준수하는 것은 보통은 불가능하다.
- OCP를 준수하는 객체지향 디자인을 만들려면 적지 않은 시간과 노력이 필요하다.
- 디자인의 모든 부분을 깔끔하게 정돈할 만큼 여유가 있는 상황도 흔치 않다. (게다가 굳이 그렇게 할 필요가 없다.)
- OCP를 지키다 보면 새로운 단계의 추상화가 필요한 경우가 종종 있는데, 추상화를 하다 보면 코드가 복잡해진다.
- 그래서 우리가 디자인한 것 중에서 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 OCP를 적용하는 방법이 가장 좋다.

**바뀌는 부분 중에서 OCP를 적용할 만큼 중요한 부분을 어떻게 골라낼 수 있나요?**
- 객체지향 시스템 디자인 경험과 지금 건드리고 있는 분야의 지식이 많다면 쉽게 구분할 수 있습니다.
- 여러 디자인을 살펴보면 바뀌는 부분 가운데 주요한 부분을 골라내는 안목이 높아집니다.

구성 요소는 총 4가지 있다.

추상 구성요소?
구상 구성요소?7
추상 데코레이터, 구상 데코레이터?
예) 
     Abstract Class Object, (추상 구성요소)

     Abstract Class Decorator extends Object (추상 데코레이터)

     Class RealObject extends Object, (구상 구성요소)

     Class RealDecorator extends Decorator (구상 데코레이터)

구상 구성요소는 이 챕터에서는 Dark Roast나 Espresso에 해당하는 것 같다.

추상 구성요소 == Beverage
추상 데코레이터 == CondimentDecorator
구상 데코레이터 == Mocha, Whip