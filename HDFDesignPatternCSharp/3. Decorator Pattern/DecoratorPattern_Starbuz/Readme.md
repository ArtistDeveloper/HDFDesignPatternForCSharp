# 초대형 커피 전문점, 스타버즈

사업을 시작할 무렵에 만들어진 주문 시스템 클래스는 다음과 같이 구성되었습니다.

![image](https://user-images.githubusercontent.com/40491724/173288129-331f72c2-338b-4e12-8504-f8e8a00b3d88.png)

- Beverage클래스의 cost()메소드는 추상 메소드입니다.
- 모든 서브클래스에서 음료의 가격을 리턴하는 cost()메소드를 구현해야 합니다.


그러나, 사업이 성공하고 규모가 커질수록 다양한 음료가 나오게 되었고 그에 맞춰 고객은 커피를 주문할 때 우유나 두유, 모카(초콜릿)을 추가하고 그 위에 휘핑크림을 얹기도 합니다.
그래서 각각을 추가할 때마다 커피 가격이 올라가야 하기에 주문 시스템을 구현할 때 이런 점을 모두 고려해야 합니다.

그래서 처음에는 시스템이 이런식으로 확장되었습니다.
![image](https://user-images.githubusercontent.com/40491724/173288149-6470c7df-2830-446c-8fb5-8171260dd3aa.png)


> cost() 메소드는 첨가물도 포함해서 커피의 최종 가격을 계산해줍니다.

기존시스템의 구조로 확장을 하다보니 클래스가 너무 많아지게 되었습니다.

위와 같은 구조의 문제점은 다음과 같습니다.
- 바뀌는 부분이 캡술화 되어있지 않습니다.
- 구성을 사용하지 않고 상속에 얽매여 있습니다.

## 1. 이 문제를 해결해볼 첫 번째 접근법
인스턴스 변수와 슈퍼클래스 상속을 써서 첨가물을 관리해봅시다.

<p align="center">
  <img src="https://user-images.githubusercontent.com/40491724/173292169-2bcb1535-5750-49c6-bf3a-fcd9543422c6.png">
</p>

1. 각 첨가물에 해당하는 불리언 변수를 새로 만들었습니다.
2. cost()를 추상 클래스로 정의하지 않고 구현합니다. 각 음료 인스턴스마다 첨가물에 해당하는 비용까지 포함할 수 있도록 말입니다. 이렇게 하더라도 서브 클래스는 cost() 메소드를 오버라이드해야 합니다. 하지만 슈퍼클래스 버전을 호출함으로써 기본 음료 가격에 추가 비용을 합친 가격을 리턴할 수 있게 됩니다.
3. has, set함수들은 첨가물의 불리언 값을 알아내거나 설정하는 게터/세터 메소드입니다.


![image](https://user-images.githubusercontent.com/40491724/173298578-ed22717d-fab0-45cf-a37a-580e64c3e9fb.png)

- 슈퍼클래스에 있는 cost()는 첨가물의 가격을 계산합니다.
- 서브클래스에서 cost() 메소드를 오버라이드 할 때 그 기능을 확장해서 특정 음료의 가격을 더합니다.

각 구상클래스의 cost()메소드는 음료의 가격을 계산한 다음 슈퍼클래스에서 구현한 cost()를 호출해서 첨가물 비용을 더합니다.

이 내용을 코드로 표현하자면 다음과 같습니다.

```csharp
    public class Beverage
    {
        // milkCost, soyCost, mochaCost, whipCost
        // 각각에 해당하는 인스턴스 변수를 선언하고
        // 우유, 두유, 모카, 휘핑크림에 대한 게터와 세터 메소드를 선언합니다.

        public double Cost()
        {
            double condimentCost = 0.0;
            if (hasMilk())
            {
                condimentCost += milkCost;
            }
            if (hasSoy())
            {
                condimentCost += soyCost;
            }
            if (hasMocha())
            {
                condimentCost += mochaCost;
            }
            if (hasWhip())
            {
                condimentCost += whipCost;
            }
            return condimentCost;
        }
    }

    public class DarkRoast : Beverage
    {
        public DarkRoast()
        {
            description = "최고의 다크 로스트 커피";
        }

        public override double Cost()
        {
            return 1.99 + base.Cost();
        }
    }
```

이 방식의 문제점을 무엇일까요?
- 첨가물 가격이 바뀔 때마다 기존 코드를 수정해야 합니다.
- 첨가물의 종류가 많아지면 새로운 메소드를 추가해야 하고, 슈퍼클래스의 cost()메소드도 고쳐야합니다.
- 새로운 음료가 출시될 수도 있습니다. 그중에는 특정 첨가물이 들어가면 안 되는 음료도 있을 것입니다. 예를 들어 아이스 티를 생각해 보면, Tea 서브클래스에서도 hasWhip() 같은 메소드가 여전히 상속받게 될 것입니다.
  - **1장에서도 경험했듯이 꽤 심각한 문제입니다.**

이 구조에서 고객이 더블 모카를 주문하면 어떻게 해야할까?
- 저였으면 milk, soy, mocha, whip의 bool변수를 short로 선언하고 해당 숫자만큼 cost를 더해지도록 구현했을 것 같습니다.


## 디자인 원칙

### OCP(Open-Closed principle)
- 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다.

우리의 목표는 기존 코드를 건드리지 않고 확장으로 새로운 행동을 추가하는 것입니다. 이 목표를 달성했을 때 얻을 수 있는 것은 새로운 기능을 추가할 때 급변하는 주변 환경에 잘 적응하는 유연하고 튼튼한 디자인을 만들 수 있습니다.

**모든 부분에서 OCP를 준수하려면 어떻게 해야 하나요?**
- 모든 부분에서 OCP를 준수하는 것은 보통은 불가능하다.
- OCP를 준수하는 객체지향 디자인을 만들려면 적지 않은 시간과 노력이 필요하다.
- 디자인의 모든 부분을 깔끔하게 정돈할 만큼 여유가 있는 상황도 흔치 않다. (게다가 굳이 그렇게 할 필요가 없다.)
- OCP를 지키다 보면 새로운 단계의 추상화가 필요한 경우가 종종 있는데, 추상화를 하다 보면 코드가 복잡해진다.
- 그래서 우리가 디자인한 것 중에서 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 OCP를 적용하는 방법이 가장 좋다.

**바뀌는 부분 중에서 OCP를 적용할 만큼 중요한 부분을 어떻게 골라낼 수 있나요?**
- 객체지향 시스템 디자인 경험과 지금 건드리고 있는 분야의 지식이 많다면 쉽게 구분할 수 있습니다.
- 여러 디자인을 살펴보면 바뀌는 부분 가운데 주요한 부분을 골라내는 안목이 높아집니다.

구성 요소는 총 4가지 있다.

추상 구성요소?
구상 구성요소?7
추상 데코레이터, 구상 데코레이터?
예) 
     Abstract Class Object, (추상 구성요소)

     Abstract Class Decorator extends Object (추상 데코레이터)

     Class RealObject extends Object, (구상 구성요소)

     Class RealDecorator extends Decorator (구상 데코레이터)

구상 구성요소는 이 챕터에서는 Dark Roast나 Espresso에 해당하는 것 같다.

추상 구성요소 == Beverage
추상 데코레이터 == CondimentDecorator
구상 데코레이터 == Mocha, Whip