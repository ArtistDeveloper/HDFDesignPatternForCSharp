# 초대형 커피 전문점, 스타버즈

사업을 시작할 무렵에 만들어진 주문 시스템 클래스는 다음과 같이 구성되었습니다.

<p align="center">
  <img width = "80%"height = "80%" src="https://user-images.githubusercontent.com/40491724/173288129-331f72c2-338b-4e12-8504-f8e8a00b3d88.png">
</p>

- Beverage클래스의 cost()메소드는 추상 메소드입니다.
- 모든 서브클래스에서 음료의 가격을 리턴하는 cost()메소드를 구현해야 합니다.


그러나, 사업이 성공하고 규모가 커질수록 다양한 음료가 나오게 되었고 그에 맞춰 고객은 커피를 주문할 때 우유나 두유, 모카(초콜릿)을 추가하고 그 위에 휘핑크림을 얹기도 합니다.
그래서 각각을 추가할 때마다 커피 가격이 올라가야 하기에 주문 시스템을 구현할 때 이런 점을 모두 고려해야 합니다.



그래서 처음에는 시스템이 이런식으로 확장되었습니다.
<p align="center">
  <img width = "80%"height = "80%" src="https://user-images.githubusercontent.com/40491724/173288149-6470c7df-2830-446c-8fb5-8171260dd3aa.png">
</p>


> cost() 메소드는 첨가물도 포함해서 커피의 최종 가격을 계산해줍니다.

기존시스템의 구조로 확장을 하다보니 클래스가 너무 많아지게 되었습니다.

위와 같은 구조의 문제점은 다음과 같습니다.
- 바뀌는 부분이 캡술화 되어있지 않습니다.
- 구성을 사용하지 않고 상속에 얽매여 있습니다.

<br/>

## 1. 이 문제를 해결해볼 첫 번째 접근법
인스턴스 변수와 슈퍼클래스 상속을 써서 첨가물을 관리해봅시다.

<p align="center">
  <img  src="https://user-images.githubusercontent.com/40491724/173292169-2bcb1535-5750-49c6-bf3a-fcd9543422c6.png">
</p>

1. 각 첨가물에 해당하는 불리언 변수를 새로 만들었습니다.
2. cost()를 추상 클래스로 정의하지 않고 구현합니다. 각 음료 인스턴스마다 첨가물에 해당하는 비용까지 포함할 수 있도록 말입니다. 이렇게 하더라도 서브 클래스는 cost() 메소드를 오버라이드해야 합니다. 하지만 슈퍼클래스 버전을 호출함으로써 기본 음료 가격에 추가 비용을 합친 가격을 리턴할 수 있게 됩니다.
3. has, set함수들은 첨가물의 불리언 값을 알아내거나 설정하는 게터/세터 메소드입니다.


<p align="center">
  <img width = "80%"height = "80%" src="https://user-images.githubusercontent.com/40491724/173298578-ed22717d-fab0-45cf-a37a-580e64c3e9fb.png">
</p>

- 슈퍼클래스에 있는 cost()는 첨가물의 가격을 계산합니다.
- 서브클래스에서 cost() 메소드를 오버라이드 할 때 그 기능을 확장해서 특정 음료의 가격을 더합니다.

각 구상클래스의 cost()메소드는 음료의 가격을 계산한 다음 슈퍼클래스에서 구현한 cost()를 호출해서 첨가물 비용을 더합니다.

이 내용을 코드로 표현하자면 다음과 같습니다.

```csharp
    public class Beverage
    {
        // milkCost, soyCost, mochaCost, whipCost
        // 각각에 해당하는 인스턴스 변수를 선언하고
        // 우유, 두유, 모카, 휘핑크림에 대한 게터와 세터 메소드를 선언합니다.

        public double Cost()
        {
            double condimentCost = 0.0;
            if (hasMilk())
            {
                condimentCost += milkCost;
            }
            if (hasSoy())
            {
                condimentCost += soyCost;
            }
            if (hasMocha())
            {
                condimentCost += mochaCost;
            }
            if (hasWhip())
            {
                condimentCost += whipCost;
            }
            return condimentCost;
        }
    }

    public class DarkRoast : Beverage
    {
        public DarkRoast()
        {
            description = "최고의 다크 로스트 커피";
        }

        public override double Cost()
        {
            return 1.99 + base.Cost();
        }
    }
```

이 방식의 문제점을 무엇일까요?
- 첨가물 가격이 바뀔 때마다 기존 코드를 수정해야 합니다.
- 첨가물의 종류가 많아지면 새로운 메소드를 추가해야 하고, 슈퍼클래스의 cost()메소드도 고쳐야합니다.
- 새로운 음료가 출시될 수도 있습니다. 그중에는 특정 첨가물이 들어가면 안 되는 음료도 있을 것입니다. 예를 들어 아이스 티를 생각해 보면, Tea 서브클래스에서도 hasWhip() 같은 메소드가 여전히 상속받게 될 것입니다.
  - **1장에서도 경험했듯이 꽤 심각한 문제입니다.**

이 구조에서 고객이 더블 모카를 주문하면 어떻게 해야할까?
- 저였으면 milk, soy, mocha, whip의 bool변수를 short로 선언하고 해당 숫자만큼 cost를 더해지도록 구현했을 것 같습니다.

<br/>

## 2. 디자인 원칙

### 상속과 구성에 대하여
챕터1 전략패턴에서 살펴보았듯이 상속이 강력하긴 하지만, 상속을 사용한다고 해서 무조건 유연하거나 관리하기 쉬운 디자인이 만들어지지 않는다는 사실을 보았습니다.

코드는 재사용을 할 수 있도록 만드는 것이 상당히 중요한데, 상속 말고 재사용이라는 목표를 달성할 수 있는 방법을 우리는 구성과 위임으로 배웠습니다.

구성과 위임을 통해 실행 중에 행동을 '상속'하는 방법이 있습니다.

서브 클래스를 만드는 방식으로 행동을 상속받으면 그 행동은 컴파일 할 때 완전히 결정됩니다. 게다가 모든 서브클래스에서 똑같은 행동을 상속받아야 합니다. 하지만 구성으로 객체의 행동을 확장하면 실행 중에 동적으로 행동을 설정할 수 있습니다.

구성을 사용하게 되면 코드 관리면에서도 상당히 유용합니다. 객체를 동적으로 구성하면 기존 코드를 고치는 대신 새로운 코드를 만들어서 기능을 추가할 수 있습니다. 기존 코드는 건드리지 않으므로 코드 수정에 따른 버그나 의도하지 않은 부작용을 원천봉쇄할 수 있습니다. (OCP를 만족할 수 있게 됩니다.)


### OCP(Open-Closed principle)
- 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다.

우리의 목표는 기존 코드를 건드리지 않고 확장으로 새로운 행동을 추가하는 것입니다. 이 목표를 달성했을 때 얻을 수 있는 것은 새로운 기능을 추가할 때 급변하는 주변 환경에 잘 적응하는 유연하고 튼튼한 디자인을 만들 수 있습니다.

<br/>

### 2.1 모든 부분에서 OCP를 준수하려면 어떻게 해야 하나요?
- 모든 부분에서 OCP를 준수하는 것은 보통은 불가능합니다.
- OCP를 준수하는 객체지향 디자인을 만들려면 적지 않은 시간과 노력이 필요합니다.
- 디자인의 모든 부분을 깔끔하게 정돈할 만큼 여유가 있는 상황도 흔치 않습니다. (게다가 굳이 그렇게 할 필요가 없다.)
- OCP를 지키다 보면 새로운 단계의 추상화가 필요한 경우가 종종 있는데, 추상화를 하다 보면 코드가 복잡해집니다.
- 그래서 우리가 디자인한 것 중에서 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 OCP를 적용하는 방법이 가장 좋습니다.

<br/>

### 2.2 코드를 변경하지 않으면서 확장이 용이한 디자인을 쉽게 만들 수 있나요?
확장하려고 코드를 직접 수정하는 일을 방지하는 디자인 기법이 있습니다. 그런 기법은 대부분 오랜 시간에 걸쳐서 검증받은 것들입니다. 3장에서는 데코레이터 패턴으로 OCP를 준수하는 방법을 배웁니다.

<br/>

### 2.3 바뀌는 부분 중에서 OCP를 적용할 만큼 중요한 부분을 어떻게 골라낼 수 있나요?
- 객체지향 시스템 디자인 경험과 지금 건드리고 있는 분야의 지식이 많다면 쉽게 구분할 수 있습니다.
- 여러 디자인을 살펴보면 바뀌는 부분 가운데 주요한 부분을 골라내는 안목이 높아집니다.

<br/>

> **Warning** <br/>
> **OCP의 주의사항** <br/><br/>
> 코드에서 확장해야 할 부분을 선택할 때는 신중해야 합니다. 무조건 OCP를 적용한다면 괜히 쓸데없는 일을 하며 시간을 낭비할 수 있습니다. 게다가 필요 이상으로 복잡하고 이해하기 힘든 코드를 만들게 되는 부작용이 발생할 수 있습니다. 이 점에 주의해야 합니다.

<br/>

### 구성요소에 대한 추가 설명
'구성요소'라는 단어를 책에서 많이 사용하는데, 잘 와닿지 않아서 내용을 추가합니다.

구성 요소는 총 4가지 있습니다.
- Abstract Class Object, (추상 구성요소)
- Abstract Class Decorator extends Object (추상 데코레이터)
- Class RealObject extends Object, (구상 구성요소)
- Class RealDecorator extends Decorator (구상 데코레이터)

책에 나오는 소스 코드에서 해당하는 것
- 추상 구성요소 == Beverage
- 구상 구성요소 == DarkRoast, Espresso
- 추상 데코레이터 == CondimentDecorator
- 구상 데코레이터 == Mocha, Whip

<br/>

## 3. 데코레이터 패턴

**데코레이터 패턴**으로 객체에 추가 요소를 동적으로 더할 수 있습니다.
데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있습니다.

<br/>

### 3.1 데코레이터 내용 정리
1. 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같습니다.
2. 한 객체를 여러 개의 데코레이터로 감쌀 수 있습니다.
3. 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체(싸여 있는 객체)가 들어갈 자리에 데코레이터 객체를 넣어도 상관없습니다.
4. **데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있습니다.**
5. 객체는 언제든지 감쌀 수 있으므로 **실행 중**에 필요한 데코레이터를 마음대로 적용할 수 있습니다.


다음 클래스 다이어그램으로 데코레이터 패턴의 개념을 살펴보겠습니다.

![image](https://user-images.githubusercontent.com/40491724/173916390-ab32603a-756d-4d3e-ac9f-9b7e66bc3866.png)

- **Component:** 각 구성 요소는 직접 쓰일 수도 있고, 데코레이터에 감싸여 쓰일 수도 있습니다.
- **ConcreteComponent:** ConcreteComponent에 새로운 행동을 동적으로 추가합니다.
- **Decorator:** 각 데코레이터 안에는 Component객체가 들어있습니다. 즉, 데코레이터에는 구성 요소의 레퍼런스를 포함한 인스턴스 변수가 있습니다.
  - Decorator는 자신이 장식할 구성 요소와 같은 인터페이스 또는 추상 클래스를 구현합니다.
- **ConcreteDecorator:**
  - ConcreteDecorator에는 데코레이터가 감싸고 있는 component 객체용 인스턴스 변수가 있습니다.
  - Decorator는 Component의 상태를 확장할 수 있습니다.
  - 데코레이터가 새로운 메소드를 추가할 수도 있습니다. 하지만 일반적으로 새로운 메소드를 추가하는 대신 Component에 원래 있던 메소드를 (호출하기 전이나 호출한 후에) 별도의 작업으로 처리해서 새로운 기능을 추가합니다.

<br/>

### 3.2 Beverage 클래스 장식하기

![image](https://user-images.githubusercontent.com/40491724/173922837-7ec3e545-b03a-47a9-9bcb-9cef26a5d379.png)

- Beverage는 앞에 나왔던 Component 추상 클래스와 비슷한 개념입니다.
- HouseBlend, DarkRoast, Espresso, Decaf: 커피 종류마다 구성 요소를 나타내는 구상 클래스를 하나씩 만들었습니다.
- Milk, Mocha, Soy, Whip: 각각의 첨가물을 나타내는 데코레이터. cost()와 getDescription()도 구현해야 합니다.

<br/>

### 3.3 흠... 상속(Inheritance)과 구성(Composition)에 대한 개념 정리..?

우리가 방금까지 살펴본 클래스 다이어그램을 보면 상속을 사용하고 있다는 것을 알게됩니다. 구성을 사용해야 좋은 것 아니었냐는 의문이 들 수도 있습니다. 이 부분을 한 번 살펴봅시다.
- CondimentDecorator에서 Beverage클래스를 확장하고 있는 것을 보니 **상속**이 맞습니다.
- 하지만, 여기서 상속이 문제가 안되는 점은 상속을 사용해서 형식을 맞추는 것이지 상속으로 행동을 물려받는 게 아니라서 괜찮습니다.
- 데코레이터 형식이 감싸는 객체의 형식과 같다는 점이 중요한 부분입니다.

행동은 어디에서 오나?
- 어떤 구성 요소(Beverage)를 가지고 데코레이터를 만들 때 새로운 행동을 추가합니다.
- 행동은 슈퍼클래스로부터 행동을 상속받아서 얻는 것이 아니라, 새로운 행동은 객체를 **구성**(composition)해서 얻는 것입니다.
- 행동을 상속받으려고 Beverage의 서브클래스를 만든 게 아니라 형식을 맞추려 하는 것입니다.
- 행동은 기본 구성 요소와는 다른 데코레이터 등을 인스턴스 변수에 저장하는 식으로 연결하는 것입니다.

즉, 객체 구성(인스턴스 변수로 다른 객체를 저장하는 방식)을 이용하고 있으니까 음료에 첨가물을 다양하게 추가해도 유연성을 잃지 않을 수 있습니다.

만약 상속만 써야 했다면 행동이 컴파일 시에 정적으로 결정되어 버립니다. 그러니까 슈퍼클래스에서 받은 것과 코드로 오버라이드 한 것만 쓸 수 있습니다. 하지만 구성을 활용하면 실행 중에 데코레이터를 마음대로 조합해서 사용할 수 있다는 장점이 있습니다.

그래서 데코레이터를 언제든지 구현해서 새로운 행동을 추가할 수도 있습니다. 상속에만 의존했다면 새로운 행동을 추가할 때마다 기존 코드를 바꿔야 했던 단점이 극복되었습니다.

그리고 구성 요소의 형식만 상속하면 되는 거라면 Beverage클래스를 왜 인터페이스로 만들지 않고 추상 클래스로 만든걸까요?
- 제일 처음 코드를 받았을 때부터 Beverage클래스가 추상 클래스를 사용하고 있어서 그렇습니다.
- 원래 데코레이터 패턴에서는 특정한 추상 구성 요소를 지정할 필요가 없어서 인터페이스를 사용하면 됩니다.
- 하지만 기존 코드를 고치는 일은 될 수 있으면 피하는 것이 좋으니까 추상 클래스를 써도 되는 상황이라면 그냥 추상 클래스만 가지고 작업을 하는게 좋을 수도 있습니다.


[구성에 관련된 개념이 필요하면 해당 링크를 참조해서 '목차 2' 부분을 읽어주세요.](https://github.com/ArtistDeveloper/HDFDesignPatternForCSharp/tree/main/HDFDesignPatternCSharp/1.%20Strategy%20pattern_DuckProject#2%EC%83%81%EC%86%8D%EA%B3%BC-%EA%B5%AC%EC%84%B1)

## 4. 자바의 코드와 C#과 다른 점

해당 링크에서 summary부분에서 차이점을 확인할 수 있습니다.

[Beverage 클래스](https://github.com/ArtistDeveloper/HDFDesignPatternForCSharp/blob/Document/HDFDesignPatternCSharp/3.%20Decorator%20Pattern/DecoratorPattern_Starbuz/Source/Beverage.cs#L19-L25)
[CondimentDecorator 클래스](https://github.com/ArtistDeveloper/HDFDesignPatternForCSharp/blob/Document/HDFDesignPatternCSharp/3.%20Decorator%20Pattern/DecoratorPattern_Starbuz/Source/CondimentDecorator.cs#L13-L17)