# 초대형 커피 전문점, 스타버즈

사업을 시작할 무렵에 만들어진 주문 시스템 클래스는 다음과 같이 구성되었습니다.

<p align="center">
  <img width = "80%"height = "80%" src="https://user-images.githubusercontent.com/40491724/173288129-331f72c2-338b-4e12-8504-f8e8a00b3d88.png">
</p>

- Beverage클래스의 cost()메소드는 추상 메소드입니다.
- 모든 서브클래스에서 음료의 가격을 리턴하는 cost()메소드를 구현해야 합니다.


그러나, 사업이 성공하고 규모가 커질수록 다양한 음료가 나오게 되었고 그에 맞춰 고객은 커피를 주문할 때 우유나 두유, 모카(초콜릿)을 추가하고 그 위에 휘핑크림을 얹기도 합니다.
그래서 각각을 추가할 때마다 커피 가격이 올라가야 하기에 주문 시스템을 구현할 때 이런 점을 모두 고려해야 합니다.



그래서 처음에는 시스템이 이런식으로 확장되었습니다.
<p align="center">
  <img width = "80%"height = "80%" src="https://user-images.githubusercontent.com/40491724/173288149-6470c7df-2830-446c-8fb5-8171260dd3aa.png">
</p>


> cost() 메소드는 첨가물도 포함해서 커피의 최종 가격을 계산해줍니다.

기존시스템의 구조로 확장을 하다보니 클래스가 너무 많아지게 되었습니다.

위와 같은 구조의 문제점은 다음과 같습니다.
- 바뀌는 부분이 캡술화 되어있지 않습니다.
- 구성을 사용하지 않고 상속에 얽매여 있습니다.

<br/>

## 1. 이 문제를 해결해볼 첫 번째 접근법
인스턴스 변수와 슈퍼클래스 상속을 써서 첨가물을 관리해봅시다.

<p align="center">
  <img  src="https://user-images.githubusercontent.com/40491724/173292169-2bcb1535-5750-49c6-bf3a-fcd9543422c6.png">
</p>

1. 각 첨가물에 해당하는 불리언 변수를 새로 만들었습니다.
2. cost()를 추상 클래스로 정의하지 않고 구현합니다. 각 음료 인스턴스마다 첨가물에 해당하는 비용까지 포함할 수 있도록 말입니다. 이렇게 하더라도 서브 클래스는 cost() 메소드를 오버라이드해야 합니다. 하지만 슈퍼클래스 버전을 호출함으로써 기본 음료 가격에 추가 비용을 합친 가격을 리턴할 수 있게 됩니다.
3. has, set함수들은 첨가물의 불리언 값을 알아내거나 설정하는 게터/세터 메소드입니다.


<p align="center">
  <img width = "80%"height = "80%" src="https://user-images.githubusercontent.com/40491724/173298578-ed22717d-fab0-45cf-a37a-580e64c3e9fb.png">
</p>

- 슈퍼클래스에 있는 cost()는 첨가물의 가격을 계산합니다.
- 서브클래스에서 cost() 메소드를 오버라이드 할 때 그 기능을 확장해서 특정 음료의 가격을 더합니다.

각 구상클래스의 cost()메소드는 음료의 가격을 계산한 다음 슈퍼클래스에서 구현한 cost()를 호출해서 첨가물 비용을 더합니다.

이 내용을 코드로 표현하자면 다음과 같습니다.

```csharp
    public class Beverage
    {
        // milkCost, soyCost, mochaCost, whipCost
        // 각각에 해당하는 인스턴스 변수를 선언하고
        // 우유, 두유, 모카, 휘핑크림에 대한 게터와 세터 메소드를 선언합니다.

        public double Cost()
        {
            double condimentCost = 0.0;
            if (hasMilk())
            {
                condimentCost += milkCost;
            }
            if (hasSoy())
            {
                condimentCost += soyCost;
            }
            if (hasMocha())
            {
                condimentCost += mochaCost;
            }
            if (hasWhip())
            {
                condimentCost += whipCost;
            }
            return condimentCost;
        }
    }

    public class DarkRoast : Beverage
    {
        public DarkRoast()
        {
            description = "최고의 다크 로스트 커피";
        }

        public override double Cost()
        {
            return 1.99 + base.Cost();
        }
    }
```

이 방식의 문제점을 무엇일까요?
- 첨가물 가격이 바뀔 때마다 기존 코드를 수정해야 합니다.
- 첨가물의 종류가 많아지면 새로운 메소드를 추가해야 하고, 슈퍼클래스의 cost()메소드도 고쳐야합니다.
- 새로운 음료가 출시될 수도 있습니다. 그중에는 특정 첨가물이 들어가면 안 되는 음료도 있을 것입니다. 예를 들어 아이스 티를 생각해 보면, Tea 서브클래스에서도 hasWhip() 같은 메소드가 여전히 상속받게 될 것입니다.
  - **1장에서도 경험했듯이 꽤 심각한 문제입니다.**

이 구조에서 고객이 더블 모카를 주문하면 어떻게 해야할까?
- 저였으면 milk, soy, mocha, whip의 bool변수를 short로 선언하고 해당 숫자만큼 cost를 더해지도록 구현했을 것 같습니다.

<br/>

## 2. 디자인 원칙

### 상속과 구성에 대하여
챕터1 전략패턴에서 살펴보았듯이 상속이 강력하긴 하지만, 상속을 사용한다고 해서 무조건 유연하거나 관리하기 쉬운 디자인이 만들어지지 않는다는 사실을 보았습니다.

코드는 재사용을 할 수 있도록 만드는 것이 상당히 중요한데, 상속 말고 재사용이라는 목표를 달성할 수 있는 방법을 우리는 구성과 위임으로 배웠습니다.

구성과 위임을 통해 실행 중에 행동을 '상속'하는 방법이 있습니다.

서브 클래스를 만드는 방식으로 행동을 상속받으면 그 행동은 컴파일 할 때 완전히 결정됩니다. 게다가 모든 서브클래스에서 똑같은 행동을 상속받아야 합니다. 하지만 구성으로 객체의 행동을 확장하면 실행 중에 동적으로 행동을 설정할 수 있습니다.

구성을 사용하게 되면 코드 관리면에서도 상당히 유용합니다. 객체를 동적으로 구성하면 기존 코드를 고치는 대신 새로운 코드를 만들어서 기능을 추가할 수 있습니다. 기존 코드는 건드리지 않으므로 코드 수정에 따른 버그나 의도하지 않은 부작용을 원천봉쇄할 수 있습니다. (OCP를 만족할 수 있게 됩니다.)


### OCP(Open-Closed principle)
- 클래스는 확장에는 열려 있어야 하지만 변경에는 닫혀 있어야 한다.

우리의 목표는 기존 코드를 건드리지 않고 확장으로 새로운 행동을 추가하는 것입니다. 이 목표를 달성했을 때 얻을 수 있는 것은 새로운 기능을 추가할 때 급변하는 주변 환경에 잘 적응하는 유연하고 튼튼한 디자인을 만들 수 있습니다.

<br/>

### 2.1 모든 부분에서 OCP를 준수하려면 어떻게 해야 하나요?
- 모든 부분에서 OCP를 준수하는 것은 보통은 불가능합니다.
- OCP를 준수하는 객체지향 디자인을 만들려면 적지 않은 시간과 노력이 필요합니다.
- 디자인의 모든 부분을 깔끔하게 정돈할 만큼 여유가 있는 상황도 흔치 않습니다. (게다가 굳이 그렇게 할 필요가 없다.)
- OCP를 지키다 보면 새로운 단계의 추상화가 필요한 경우가 종종 있는데, 추상화를 하다 보면 코드가 복잡해집니다.
- 그래서 우리가 디자인한 것 중에서 가장 바뀔 가능성이 높은 부분을 중점적으로 살펴보고 OCP를 적용하는 방법이 가장 좋습니다.

<br/>

### 2.2 코드를 변경하지 않으면서 확장이 용이한 디자인을 쉽게 만들 수 있나요?
확장하려고 코드를 직접 수정하는 일을 방지하는 디자인 기법이 있습니다. 그런 기법은 대부분 오랜 시간에 걸쳐서 검증받은 것들입니다. 3장에서는 데코레이터 패턴으로 OCP를 준수하는 방법을 배웁니다.

<br/>

### 2.3 바뀌는 부분 중에서 OCP를 적용할 만큼 중요한 부분을 어떻게 골라낼 수 있나요?
- 객체지향 시스템 디자인 경험과 지금 건드리고 있는 분야의 지식이 많다면 쉽게 구분할 수 있습니다.
- 여러 디자인을 살펴보면 바뀌는 부분 가운데 주요한 부분을 골라내는 안목이 높아집니다.

<br/>

> **Warning** <br/><br/>
> **OCP의 주의사항** <br/><br/>
> 코드에서 확장해야 할 부분을 선택할 때는 신중해야 합니다. 무조건 OCP를 적용한다면 괜히 쓸데없는 일을 하며 시간을 낭비할 수 있습니다. 게다가 필요 이상으로 복잡하고 이해하기 힘든 코드를 만들게 되는 부작용이 발생할 수 있습니다. 이 점에 주의해야 합니다.

<br/>

### 구성요소에 대한 추가 설명
'구성요소'라는 단어를 책에서 많이 사용하는데, 잘 와닿지 않아서 내용을 추가합니다.

구성 요소는 총 4가지 있습니다.
- Abstract Class Object, (추상 구성요소)
- Abstract Class Decorator extends Object (추상 데코레이터)
- Class RealObject extends Object, (구상 구성요소)
- Class RealDecorator extends Decorator (구상 데코레이터)

책에 나오는 소스 코드에서 해당하는 것
- 추상 구성요소 == Beverage
- 구상 구성요소 == DarkRoast, Espresso
- 추상 데코레이터 == CondimentDecorator
- 구상 데코레이터 == Mocha, Whip

