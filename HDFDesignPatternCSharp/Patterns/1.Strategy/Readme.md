## 목차
[1. 전략 패턴](#1전략-패턴strategy-pattern) <br/>
[2. 상속과 구성](#2상속과-구성) <br/>
[3. 전략 패턴이란](#전략-패턴) <br/>

## 1.전략 패턴(strategy pattern)
![image](https://user-images.githubusercontent.com/40491724/171191181-68213905-6427-48c3-8a84-e50a752dff81.png)

위의 이미지 처럼 코드 구조를 짤 수 있으려면, 인터페이스 형식(굳이 interface가 아닌 상위 형식을 말함)에 맞추어 개발하는 것이 중요합니다.

### 캡슐화
- 달라지는 부분을 찾아서 나머지 코드에 영향을 주지 않도록 ‘캡슐화’ 합니다.
- 이러면 나중에 바뀌지 않는 부분에는 영향을 미치지 않고 그 부분만 고치거나 확장할 수 있습니다.
- 이 방법은 모든 패턴의 기반을 이루는 원칙입니다.


### 디자인 원칙
> **Note**
> - 상속보다는 구성을 활용한다.
> - 구현보다는 인터페이스에 맞춰서 프로그래밍한다.

<br/>

## 2.상속과 구성

책에서 구성을 예시로 든 설명은 다음과 같습니다.
- "A에는 B가 있다" 관게를 생각해 봅시다. (Duck 클래스에 FlyBehavior와 QuackBehavior가 있다는 것을 말하고 싶은 것 같습니다.)
- 각 오리에는 FlyBehavior와 QuackBehavior가 있으며, 각각 나는 행동과 꽥꽥거리는 행동을 위임 받습니다.
- 이런 식으로 두 클래스를 합치는 것을 '구성(Composition)을 이용한다'라고 부릅니다.
- 오리 클래스에서는 행동을 상속받는 대신, 올바른 행동 객체로 구성되어 행동을 부여 받습니다.

그리고 추가적으로 상속과 구성에 대해 설명을 해보겠습니다.

<br/>

### 2.1 상속의 단점

**캡슐화를 위반한다.**
- 상위 클래스가 어떻게 구현되느냐에 따라 하위 클래스의 동작에 이상이 생길 수 있기 때문입니다.
- 상위 클래스의 내부 구현이 달라지면 하위 클래스를 고쳐야할 수 있습니다.

**설계가 유연하지 못하다.**
- 컴파일 시점에 객체의 Type이 정해지기 때문입니다.

**다중상속**
- C#, Java는 다중상속이 불가능합니다.
- 따라서 다른 클래스를 상속받고 있다면 추가적으로 상속을 받을 수 없습니다.

물론 상속은 코드를 재사용할 수 있는 강력한 수단이지만, 객체의 유연성을 해치는 결과도 초래할 수 있으므로 잘 사용하는 것이 중요합니다.

<br/>

### 2.2 구성(Composition)이란
책을 보면서 구성에 대해 어렴풋이 알게 된 것 같긴한데, 잘 모르겠다는 느낌은 여전히 받고 있었습니다. 그래서 구성에 대해서 조금 더 알아보고 작성해보았습니다.

[구성에 대해 좋은 설명을 들고 왔습니다.](https://tecoble.techcourse.co.kr/post/2020-05-18-inheritance-vs-composition/)
> **구성(Composition)**: 기존 클래스가 새로운 클래스의 구성요소로 쓰인다. 새로운 클래스를 만들고 private 필드로 기존 클래스의 인스턴스를 참조한다.

구성에 대한 코드 예시
```csharp
public class Soccer
{
    private string ballName = "soccerBall";

    public string GetBallName()
    {
        return ballName;
    }
}

public class BallSport
{
    private Soccer soccer;

    public BallSport()
    {
        soccer = new Soccer();
    }

    public string GetBallName()
    {
        return soccer.GetBallName();
    }
}

```
**구성은 다음과 같을 때 말합니다.**
- 위 코드처럼 class BallSport에 class Soccer 변수가 선언되어 있는 구조 
- class Soccer의 라이프 사이클이 class BallSport에 종속됨을 의미함.

**구성의 장점**
1. 메서드를 호출하는 방식으로 동작하기 때문에 캡슐화를 깨뜨리지 않습니다.
2. Soccer클래스의 영향이 생겨도 BallSport클래스에 영향이 적어지며, 안전합니다.
3. 책에서 나온대로의 구성 방법을 활용하면, Type문제에 있어서도 한 층 가벼워집니다.

<br/>

## 전략 패턴
알고리즘군을 정의하고 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해 줍니다. 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 분리할 수 있습니다.




